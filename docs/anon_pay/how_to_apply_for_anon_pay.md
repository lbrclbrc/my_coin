Client ↔ Node Protocol  AnonPay

Scope
- Wire format for applying an anonymous-note-to-public-account payment.
- Amount is public. No extra signature. Uses ZK proof.
- Block tx format is specified in anon_pay_in_blocks_v1.

0. JSON value types
- Hex32 and HexField and ZKProofHex are JSON strings.
- version and amount are JSON integers.

Canonical encodings
- Hex32  
  string hex for 32 bytes, 64 chars, lowercase, no "0x".
- HexField  
  string hex, lowercase, even length, no "0x".
- ZKProofHex  
  HexField of zk proof bytes from get_zkproof_for_anon_pay.

1. Request envelope
{
  "application_type": string,
  "payload": dict
}

2. AnonPay request

Request envelope
{
  "application_type": "AnonPay",
  "payload": {
    "version":       1,
    "to_addr":       Hex32,
    "amount":        int,
    "nullifier":     Hex32,
    "commit_change": Hex32,
    "zk_proof":      ZKProofHex
  }
}

How Client fills payload (API pointers only)
- version  
  constant 1
- to_addr  
  receiver on-chain address (public account)
- amount  
  positive integer in the FieldIntNonNeg range (1 ≤ amount ≤ 2^96 − 1, matching node-side checks); public payment value
- nullifier  
  computed as Poseidon(sk_bytes, nonce_bytes, src_bytes) for the old note
- commit_change  
  computed as Poseidon(
    value_change_bytes,
    sk_bytes,
    ZERO32_bytes,
    nullifier_bytes
  )
  where value_change = value_initial - amount
- zk_proof  
  generated by calling get_zkproof_for_anon_pay(
    pin_root,            # current anon commit_root_before
    pin_nullifier,       # = nullifier
    pin_commit_change,   # = commit_change
    pin_value_pay,       # = amount
    sin_value_initial,
    sin_value_change,
    sin_sk,
    sin_nonce_initial,
    sin_src,
    sin_siblings,
    sin_dirs
  )
  then hex-encoding the returned proof bytes

Note on signatures
- No additional signature field is required.
- Ownership and spending authority of the anonymous note are enforced
  by the zk_proof via nullifier and Merkle path constraints.

3. Node response

Success
{
  "ok": True,
  "new_block": {
    "account_root":  Hex32,
    "tx_root":       Hex32,
    "commit_root":   Hex32,

    "applied_addr":  Hex32,  # same as to_addr
    "to_addr":       Hex32,
    "amount":        int,
    "nullifier":     Hex32,
    "commit_change": Hex32,

    "tx": {
      "tx_type": "AnonPayTx",
      "payload": dict
    }
  }
}

Failure
{
  "ok":  False,
  "err": string
}

Client handling rule
- If ok False log err and treat as not accepted.
- If ok True pass new_block to blockchain core for chain update.

End
