EccKeypair (Python Class) — Usage Guide (my_coin)

Summary
- This class manages a Pallas ECC keypair and Schnorr-style signatures.
- It is a Python wrapper over a Rust backend (PastaECCKeyPairs).
- All external I/O uses raw bytes (not hex strings).

On-object fields (Python-visible)

1) sk: bytes | None
   - Meaning: secret key material.
   - Type: exactly 32 raw bytes when set; otherwise None.
   - Domain / constraints:
       * Length must be exactly 32 bytes.
       * When generated by get_sk(), the integer value is reduced mod R (see constants),
         then encoded as 32-byte little-endian.

2) pk: bytes | None
   - Meaning: compressed Pallas public key.
   - Type: exactly 32 raw bytes when set/derived; otherwise None.
   - Domain / constraints:
       * Length must be exactly 32 bytes.
       * Represents a compressed Pallas curve point using Pasta GroupEncoding
         (see “PK compression format”).

3) _rs: zkcrypto.PastaECCKeyPairs
   - Meaning: Rust-side object holding the authoritative SK/PK for cryptographic ops.
   - Type: internal Rust binding; not part of protocol state.

Exported constants (from wrapper)

- R = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001
  Base-field modulus used by get_sk() for reduction.

- P = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001
  Scalar-field modulus (curve order) used by Rust scalar arithmetic.

Constructor

- k = EccKeypair(sk=None)
  - If sk is None:
      * sk and pk start as None.
      * No key is generated until get_sk() or set_sk() is called.
  - If sk is provided:
      * Must be bytes-like and exactly 32 bytes.
      * Equivalent to calling set_sk(sk) immediately.
      * The SK is stored in Python and also pushed into Rust (_rs.set_sk_from_bytes).

Key management methods

1) set_sk(sk_bytes) -> None
   Input:
     - sk_bytes: bytes-like, length == 32.
   Behavior:
     - Stores sk_bytes into k.sk.
     - Pushes sk_bytes into Rust backend.
     - Clears cached pk (k.pk = None).
   Interpretation in Rust:
     - Rust interprets these 32 bytes as a big-endian integer and reduces it mod P
       to obtain the scalar used for all curve operations.

2) get_sk() -> bytes
   Output:
     - Returns 32 bytes (k.sk).
   Behavior (Python-side):
     - rand = os.urandom(32)
     - sk_int = int_from_little_endian(rand) mod R
     - sk_bytes = sk_int encoded as 32-byte little-endian
     - Stores and pushes sk_bytes into Rust, clears cached pk.
   Guarantee:
     - The integer represented by returned sk_bytes is in:
         0 <= sk_int < R
     - Since R < P, it is always a valid scalar input for Rust operations.

3) set_pk(pk_bytes) -> None
   Input:
     - pk_bytes: bytes-like, length == 32.
   Behavior:
     - Stores pk_bytes into k.pk.
     - Pushes pk_bytes into Rust backend (_rs.set_pk_from_bytes).
     - Does not modify sk.

4) get_pk_from_sk(compressed=True) -> bytes
   Preconditions:
     - k.sk must be set (via get_sk, set_sk, or constructor sk=...).
   Behavior (Rust-side derivation):
     - sk_scalar = Scalar( sk_bytes interpreted as big-endian mod P )
     - pk_point = G * sk_scalar   (G is the Pallas generator)
     - pk_bytes = Compress(pk_point)
   Output:
     - Returns 32-byte compressed PK and caches it in k.pk.
   Note:
     - The compressed parameter is accepted but ignored; output is always compressed.

5) get_pk_cached() -> bytes | None
   Behavior:
     - If k.pk exists, returns it.
     - Else tries Rust-side cached pk; if absent, returns None.
     - Never derives a new pk.

PK compression format (what pk bytes mean)
- pk_bytes is the Pasta Pallas GroupEncoding compressed form, length 32 bytes.
- Encoding layout:
  - The lower 255 bits encode the affine x-coordinate in little-endian.
  - The highest bit (MSB of the last byte) encodes the “sign/parity” choice of y
    (which square-root branch to take).
- To decompress externally:
  - Recover x from the lower 255 bits (little-endian).
  - Use the top-bit to select the correct y root on the Pallas curve.

Signing and verification

6) sign(msg) -> (r_bytes, s_bytes, raw_sig)
   Preconditions:
     - k.sk must be set.
   Input:
     - msg: bytes-like.
   Behavior (Rust Schnorr over Pallas):
     - k_rand <- random scalar in Pallas scalar field
     - R_point = k_rand * G
     - r_bytes = Compress(R_point)  (32 bytes)
     - pk_bytes = Compress(G * sk_scalar)  (cached)
     - e = H( r_bytes || pk_bytes || msg ) mapped into scalar field
     - s = k_rand + e * sk_scalar   (mod P)
     - s_bytes = canonical scalar bytes (32 bytes, little-endian repr)
     - raw_sig = r_bytes || s_bytes  (64 bytes)
   Hash H used here:
     - Blake2b-512 over the concatenated bytes.
     - The 64-byte digest is interpreted as a big-endian integer and reduced mod P
       to obtain e.

   Output:
     - r_bytes: 32-byte compressed R point.
     - s_bytes: 32-byte canonical scalar repr.
     - raw_sig: 64 bytes = r_bytes || s_bytes.

7) verify_signature(signature, msg) -> bool
   Preconditions:
     - A valid pk must already be set/cached (verify uses PK only).
       You can ensure this via:
         * set_pk(pk_bytes), or
         * get_pk_from_sk() after setting sk, or
         * sign() once (sign caches pk).
   Inputs:
     - msg: bytes-like.
     - signature:
         A) raw 64-byte bytes (r||s), or
         B) (r_bytes, s_bytes) tuple/list, each 32 bytes.
   Behavior:
     - Parse r_bytes as compressed point R_point.
     - Parse s_bytes as canonical scalar (little-endian repr).
     - Recompute e = Blake2b-512( r_bytes || pk_bytes || msg ), reduced mod P
       using big-endian digest interpretation.
     - Check Schnorr equation:
         s*G == R + e*PK
   Output:
     - True if valid, else False.

Endianness checklist (explicit)

- get_sk():
    * Converts random 32B to integer using little-endian.
    * Reduces mod R.
    * Stores SK as 32B little-endian.
- set_sk():
    * Accepts any 32B as-is; no byte-order conversion in Python.
    * Rust interprets those 32B as big-endian when mapping to a scalar mod P.
- pk_bytes / r_bytes:
    * Compressed point encoding: little-endian x + top-bit for y parity.
- s_bytes:
    * Canonical scalar repr from Rust PrimeField::to_repr;
      used in your tests as little-endian.

Debug helper

8) derive_and_print() -> None
   - If sk is None, calls get_sk().
   - Derives pk via get_pk_from_sk().
   - Prints type/length/hex prefixes for quick inspection.

Important notes
- Always pass raw bytes, never hex strings.
- Length rules are strict:
    SK 32 bytes, PK 32 bytes, raw signature 64 bytes.
- verify_signature uses PK only; SK is not consulted during verify.
