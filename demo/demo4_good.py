#!/usr/bin/env python3
# demo/demo4_good.py
#
# Demo 4 (GOOD):
#   5 blue users deposit to the anon pool, then Alice sends several
#   anonymous payments to Bob, and finally Bob deposits again.
#
# Flow:
#   1) Alice/Bob/Charlie/Dave/Eve:
#        BlueApply1 -> get blue addr with default balance (500).
#   2) Everyone deposits 300 from their blue account to the anon pool
#        (AcctToAnon).
#   3) Alice spends her anon note with 4 chained AnonPay steps
#        to Bob (200 + 50 + 25 + 20), each time creating a change note.
#   4) Bob deposits 300 from his blue account to the anon pool again.
#
# The zk proof for AcctToAnon is not expanded in this demo (see demo3).
# Here I focus on the zk proof used by AnonPay.

import os
import sys

# Add project root to sys.path
THIS_FILE = os.path.abspath(__file__)
THIS_DIR = os.path.dirname(THIS_FILE)
PROJECT_ROOT = os.path.abspath(os.path.join(THIS_DIR, ".."))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

import acct 
from client.core import Client
from node.core import Node
from tools import short_hex, run_silently
from demo.demo1_good import build_demo_cert_for_client, run_blue_apply1_flow
from demo.demo3_good import run_acct_to_anon


def build_merkle_path_for_commit(node: Node, commit_hex: str):
    """
    Build a fixed-depth Merkle path (siblings, dirs) for a given anon
    commitment under node.node_commitment_tree.
    """
    index = node.list_of_note_commitments.index(commit_hex)
    proof_pairs = node.node_commitment_tree.gen_proof(index)

    siblings = []
    dirs = []

    i = 0
    while i < len(proof_pairs):
        sib_hex, direction = proof_pairs[i]
        siblings.append(sib_hex)
        if direction == "R":
            dirs.append(0)
        else:
            dirs.append(1)
        i += 1

    root_hex = node.node_commitment_tree.root()
    return root_hex, siblings, dirs


def run_acct_to_anon_simple(
    client: Client,
    owner_label: str,
    blue_acct,
    amount: int,
    node: Node,
):
    """
    Run a single AcctToAnon deposit for a blue account.

    return:
      updated_acct, anon_commit_hex, nonce_int
    """
    addr = blue_acct.addr
    client.Dict_of_accts[addr] = blue_acct

    header_msg = (
        f"[DEMO4] [{owner_label}] AcctToAnon deposit\n"
        f"[DEMO4]   from_addr = {short_hex(addr)}\n"
        f"[DEMO4]   amount    = {amount}\n"
    )
    print(header_msg)

    # reuse demo3 api
    result = run_acct_to_anon(
        client=client,
        owner_label=owner_label,
        acct=blue_acct,
        amount=amount,
        node=node,
        explain_proof=False,
        quiet=True,
    )

    updated = result["updated_acct"]
    anon_commit = result["anon_commit"]
    nonce = result["nonce"]

    if updated is not None:
        updated.ecc_keypair = blue_acct.ecc_keypair
        client.Dict_of_accts[addr] = updated

    return updated, anon_commit, nonce


def explain_anon_pay_proof(
    owner_label: str,
    root_hex: str,
    payload: dict,
    value_initial: int,
    value_change: int,
) -> None:
    """
    Print an informal statement of the zk proof used by AnonPay for this step.
    """
    value_pay = payload["amount"]
    nullifier = payload["nullifier"]
    commit_change = payload["commit_change"]
    zk_proof = payload["zk_proof"]

    msg = (
        "[DEMO4] ZK proof for AnonPay (informal statement):\n"
        f"[DEMO4]   Sender      = {owner_label}\n"
        "[DEMO4]   Public inputs (32-byte field encodings):\n"
        f"[DEMO4]     root           = {short_hex(root_hex)}\n"
        f"[DEMO4]     nullifier      = {short_hex(nullifier)}\n"
        f"[DEMO4]     commit_change  = {short_hex(commit_change)}\n"
        f"[DEMO4]     value_pay      = {value_pay}\n"
        "[DEMO4]   Secret witness (not revealed on chain):\n"
        f"[DEMO4]     value_initial  = {value_initial}\n"
        f"[DEMO4]     value_change   = {value_change}\n"
        "[DEMO4]     sk, nonce_initial, src,\n"
        "[DEMO4]     plus the Merkle path (siblings, dirs) of the old note.\n"
        "[DEMO4]   The circuit checks, roughly:\n"
        "[DEMO4]     1) The old note commitment is in the tree under 'root'.\n"
        "[DEMO4]     2) nullifier = Poseidon(sk, nonce_initial, src).\n"
        "[DEMO4]     3) The old note and change note use the same sk,\n"
        "[DEMO4]        and value_initial = value_pay + value_change\n"
        "[DEMO4]        in an integer range (no mod-P wraparound).\n"
        "[DEMO4]     4) commit_change = Poseidon(value_change, sk, 0, nullifier).\n"
        f"[DEMO4]   Proof bytes (truncated) = {short_hex(zk_proof)}\n"
        "[DEMO4]   The proof is generated by get_zkproof_for_anon_pay(...)\n"
        "[DEMO4]   and verified by verify_zkproof_for_anon_pay(...) inside the node.\n"
    )
    print(msg)


def run_anon_pay_step(
    sender_client: Client,
    sender_label: str,
    blue_acct,
    note_value_initial: int,
    pay_amount: int,
    note_nonce_bytes: bytes,
    note_src_bytes: bytes,
    note_commit_hex: str,
    receiver_addr: str,
    node: Node,
    explain_proof: bool = False,
):
    """
    Spend one anon note using AnonPay and create a change note.

    Returns:
      (change_commit_hex, change_value_int, new_nullifier_hex)
    """
    root_hex, siblings, dirs = build_merkle_path_for_commit(node, note_commit_hex)
    change_value = note_value_initial - pay_amount

    header_msg = (
        f"[DEMO4] [{sender_label}] AnonPay\n"
        f"[DEMO4]   value_initial = {note_value_initial}\n"
        f"[DEMO4]   pay           = {pay_amount}\n"
        f"[DEMO4]   change        = {change_value}\n"
        f"[DEMO4]   tree_root     = {short_hex(root_hex)}\n"
    )
    print(header_msg)

    envelope = run_silently(
        sender_client.apply_for_anon_pay,
        blue_acct,
        root_hex,
        receiver_addr,
        pay_amount,
        note_value_initial,
        note_nonce_bytes,
        note_src_bytes,
        siblings,
        dirs,
    )
    payload = envelope["payload"]

    env_msg = (
        "[DEMO4]   envelope payload (truncated):\n"
        f"[DEMO4]     to_addr       = {short_hex(payload['to_addr'])}\n"
        f"[DEMO4]     amount        = {payload['amount']}\n"
        f"[DEMO4]     nullifier     = {short_hex(payload['nullifier'])}\n"
        f"[DEMO4]     commit_change = {short_hex(payload['commit_change'])}\n"
        f"[DEMO4]     zk_proof      = {short_hex(payload['zk_proof'])}\n"
    )
    print(env_msg)

    if explain_proof:
        explain_anon_pay_proof(
            sender_label,
            root_hex,
            payload,
            note_value_initial,
            change_value,
        )

    # see new blocks only
    res = run_silently(node.deal_with_request, envelope)
    nb = res["new_block"]

    block_msg = (
        "[DEMO4][OK] AnonPay accepted by node. Block summary:\n"
        f"  [DEMO4] account_root = {short_hex(nb['account_root'])}\n"
        f"  [DEMO4] commit_root  = {short_hex(nb['commit_root'])}\n"
        f"  [DEMO4] nullifier    = {short_hex(nb['nullifier'])}\n"
        f"  [DEMO4] commit_change= {short_hex(nb['commit_change'])}\n"
    )
    print(block_msg)

    change_commit_hex = payload["commit_change"]
    new_nullifier_hex = payload["nullifier"]

    return change_commit_hex, change_value, new_nullifier_hex


def demo4_good_test():
    print("========== DEMO 4 (GOOD): 5 blue users, anon deposits, multi-step AnonPay ==========\n")

    # Clear current_blockchain.txt so this demo starts from a clean file.
    chain_path = os.path.join(PROJECT_ROOT, "current_blockchain.txt")
    with open(chain_path, "w", encoding="utf-8") as f:
        f.write("")
    print("[DEMO4] Cleared current_blockchain.txt\n")

    # 1. Initialize node and clients (hide their internal logs).
    node = run_silently(Node)
    print("[DEMO4] Node initialized.\n")

    names = ["Alice", "Bob", "Charlie", "Dave", "Eve"]
    clients = []

    i = 0
    while i < len(names):
        name = names[i]
        print(f"[DEMO4] Creating client for {name}...")
        cli = run_silently(Client, cert={})
        pwd = f"{name.lower()}_password_demo4"
        run_silently(cli.set_master_seed_from_password, pwd)
        print(f"[DEMO4]   {name} MASTER_SEED (short) = {short_hex(cli.MASTER_SEED.hex())}")
        run_silently(build_demo_cert_for_client, cli)
        clients.append(cli)
        i = i + 1
        print()

    # 2. BlueApply1 for all users
    print("========== STEP 1: BlueApply1 for 5 users ==========\n")

    blue_accts = {}

    i = 0
    while i < len(names):
        name = names[i]
        cli = clients[i]

        blue_acct = run_silently(run_blue_apply1_flow, cli, node)
        blue_accts[name] = blue_acct

        print(f"[DEMO4] {name} blue addr = {short_hex(blue_acct.addr)}")

        i = i + 1

    print()

    alice = clients[0]
    bob = clients[1]
    charlie = clients[2]
    dave = clients[3]
    eve = clients[4]

    alice_blue = blue_accts["Alice"]
    bob_blue = blue_accts["Bob"]
    charlie_blue = blue_accts["Charlie"]
    dave_blue = blue_accts["Dave"]
    eve_blue = blue_accts["Eve"]

    # 3. Everyone deposits 300 to the anon pool.
    print("========== STEP 2: Everyone AcctToAnon deposit 300 ==========\n")

    deposit_amount = 300

    alice_blue, alice_anon_commit, alice_nonce_int = run_acct_to_anon_simple(
        alice, "Alice", alice_blue, deposit_amount, node
    )
    print()

    bob_blue, _, _ = run_acct_to_anon_simple(
        bob, "Bob", bob_blue, deposit_amount, node
    )
    print()

    charlie_blue, _, _ = run_acct_to_anon_simple(
        charlie, "Charlie", charlie_blue, deposit_amount, node
    )
    print()

    dave_blue, _, _ = run_acct_to_anon_simple(
        dave, "Dave", dave_blue, deposit_amount, node
    )
    print()

    eve_blue, _, _ = run_acct_to_anon_simple(
        eve, "Eve", eve_blue, deposit_amount, node
    )
    print()

    # 4. Alice performs a chain of 4 AnonPay steps to Bob.
    print("========== STEP 3: Alice chained AnonPay to Bob ==========\n")

    alice_note_value = deposit_amount
    alice_note_nonce_bytes = alice_nonce_int.to_bytes(32, "big")
    alice_note_src_bytes = bytes.fromhex(alice_blue.addr)
    alice_note_commit = alice_anon_commit

    # Step 3.1: pay 200, change = 100
    change_commit_1, change_value_1, nullifier_1 = run_anon_pay_step(
        sender_client=alice,
        sender_label="Alice (layer 1)",
        blue_acct=alice_blue,
        note_value_initial=alice_note_value,
        pay_amount=200,
        note_nonce_bytes=alice_note_nonce_bytes,
        note_src_bytes=alice_note_src_bytes,
        note_commit_hex=alice_note_commit,
        receiver_addr=bob_blue.addr,
        node=node,
        explain_proof=True,
    )
    print()

    # Step 3.2: pay 50 from change(100), change = 50
    alice_note_value = change_value_1
    alice_note_nonce_bytes = (0).to_bytes(32, "big")
    alice_note_src_bytes = bytes.fromhex(nullifier_1)
    alice_note_commit = change_commit_1

    change_commit_2, change_value_2, nullifier_2 = run_anon_pay_step(
        sender_client=alice,
        sender_label="Alice (layer 2)",
        blue_acct=alice_blue,
        note_value_initial=alice_note_value,
        pay_amount=50,
        note_nonce_bytes=alice_note_nonce_bytes,
        note_src_bytes=alice_note_src_bytes,
        note_commit_hex=alice_note_commit,
        receiver_addr=bob_blue.addr,
        node=node,
        explain_proof=False,
    )
    print()

    # Step 3.3: pay 25 from change(50), change = 25
    alice_note_value = change_value_2
    alice_note_nonce_bytes = (0).to_bytes(32, "big")
    alice_note_src_bytes = bytes.fromhex(nullifier_2)
    alice_note_commit = change_commit_2

    change_commit_3, change_value_3, nullifier_3 = run_anon_pay_step(
        sender_client=alice,
        sender_label="Alice (layer 3)",
        blue_acct=alice_blue,
        note_value_initial=alice_note_value,
        pay_amount=25,
        note_nonce_bytes=alice_note_nonce_bytes,
        note_src_bytes=alice_note_src_bytes,
        note_commit_hex=alice_note_commit,
        receiver_addr=bob_blue.addr,
        node=node,
        explain_proof=False,
    )
    print()

    # Step 3.4: pay 20 from change(25), change = 5
    alice_note_value = change_value_3
    alice_note_nonce_bytes = (0).to_bytes(32, "big")
    alice_note_src_bytes = bytes.fromhex(nullifier_3)
    alice_note_commit = change_commit_3

    change_commit_4, change_value_4, nullifier_4 = run_anon_pay_step(
        sender_client=alice,
        sender_label="Alice (layer 4)",
        blue_acct=alice_blue,
        note_value_initial=alice_note_value,
        pay_amount=20,
        note_nonce_bytes=alice_note_nonce_bytes,
        note_src_bytes=alice_note_src_bytes,
        note_commit_hex=alice_note_commit,
        receiver_addr=bob_blue.addr,
        node=node,
        explain_proof=False,
    )
    print(f"[DEMO4] Alice final change note: value = {change_value_4}, commit = {short_hex(change_commit_4)}\n")

    # Refresh Alice and Bob blue accounts from node for the final state.
    alice_blue = run_silently(alice.fetch_account_from_node, node, alice_blue.addr)
    if alice_blue is not None:
        alice_blue.ecc_keypair = blue_accts["Alice"].ecc_keypair

    bob_blue = run_silently(bob.fetch_account_from_node, node, bob_blue.addr)
    if bob_blue is not None:
        bob_blue.ecc_keypair = blue_accts["Bob"].ecc_keypair

    # 5. Bob deposits 300 again to the anon pool.
    print("========== STEP 4: Bob AcctToAnon deposit 300 again ==========\n")

    bob_blue, bob_second_commit, bob_second_nonce_int = run_acct_to_anon_simple(
        bob, "Bob (second deposit)", bob_blue, 300, node
    )

    # 6. Final account snapshots.
    print("\n========== Final Accounts ==========")
    alice_blue.debug_print("[DEMO4] Alice final blue acct:")
    bob_blue.debug_print("[DEMO4] Bob final blue acct:")
    charlie_blue.debug_print("[DEMO4] Charlie final blue acct:")
    dave_blue.debug_print("[DEMO4] Dave final blue acct:")
    eve_blue.debug_print("[DEMO4] Eve final blue acct:")

    # Simple consistency checks (balance pattern and chain integrity).
    is_everything_right = True

    chain_ok = node.blockchain.verify_chain()
    if not chain_ok:
        is_everything_right = False

    if (
        alice_blue is None
        or bob_blue is None
        or charlie_blue is None
        or dave_blue is None
        or eve_blue is None
    ):
        is_everything_right = False
    else:
        if alice_blue.balance != 200:
            is_everything_right = False
        if bob_blue.balance != 195:
            is_everything_right = False
        if charlie_blue.balance != 200:
            is_everything_right = False
        if dave_blue.balance != 200:
            is_everything_right = False
        if eve_blue.balance != 200:
            is_everything_right = False

    # Count AnonPayTx on chain (should be 4).
    anon_pay_count = 0
    bi = 0
    while bi < len(node.blockchain.lst_of_blocks):
        blk = node.blockchain.lst_of_blocks[bi]
        if blk.lst_of_txs is not None:
            tj = 0
            while tj < len(blk.lst_of_txs):
                tx = blk.lst_of_txs[tj]
                if isinstance(tx, dict):
                    if "tx_type" in tx:
                        if tx["tx_type"] == "AnonPayTx":
                            anon_pay_count = anon_pay_count + 1
                tj = tj + 1
        bi = bi + 1
    if anon_pay_count != 4:
        is_everything_right = False

    print("\n========== Final Blockchain State ==========")
    print(node.blockchain)

    print(f"\n[DEMO4] is_everything_right = {is_everything_right}")

    return node.blockchain, alice.MASTER_SEED


if __name__ == "__main__":
    demo4_good_test()
